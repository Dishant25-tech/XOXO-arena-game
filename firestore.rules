
/**
 * This ruleset enforces a strict user-ownership security model for a Tic Tac Toe application.
 *
 * Core Philosophy:
 * The security model is built on the principle that users have exclusive control over their own
 * data. All user-specific information, including settings and game history, is isolated
 * within a data tree owned by that user. The public `games` collection allows for real-time
 * multiplayer matchmaking, with strict rules to ensure only an active player can modify a game state.
 *
 * Data Structure:
 * - /users/{userId}: Stores the user's public profile and private subcollections.
 * - /users/{userId}/settings: Contains private, user-specific application settings.
 * - /users/{userId}/game_records: A history of games played by the user.
 * - /games/{gameId}: A live game session, accessible to authenticated users for discovery and play.
 *
 * Key Security Decisions:
 * - User Enumeration Disabled: Listing the top-level `/users` collection is disallowed to protect user privacy.
 * - Self-Service Profile: A user can create and manage their own profile document.
 * - Path-Based Access Control: Security for user subcollections (`settings`, `game_records`) is determined
 *   by the `{userId}` in the path.
 * - Live Game Access: The `/games` collection is readable by any authenticated user to find an open game.
 *   However, writing to a game document is strictly controlled.
 * - Atomic Game Moves: Only the player whose turn it is can update the `board`. Players cannot change
 *   the game's creator (`player1Id`), join a full game, or alter critical immutable fields.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // -- User Profile Helpers --
    function hasValidUserCreateData(userId) {
      return request.resource.data.id == userId;
    }

    function hasValidUserUpdateData() {
      return request.resource.data.id == resource.data.id;
    }

    // -- User Settings Helpers --
    function hasValidSettingCreateData(userId) {
      return request.resource.data.userId == userId;
    }

    function hasValidSettingUpdateData() {
      return request.resource.data.userId == resource.data.userId;
    }

    // -- Game Record Helpers --
    function hasValidGameRecordCreateData(userId) {
      return request.resource.data.player1Id == userId;
    }

    function hasValidGameRecordUpdateData() {
      return request.resource.data.player1Id == resource.data.player1Id;
    }
    
    // -- Live Game Helpers --
    function isGamePlayer(game) {
      return isSignedIn() && (request.auth.uid == game.data.player1Id || request.auth.uid == game.data.player2Id);
    }

    function isNextPlayer(game) {
      return isSignedIn() && request.auth.uid == game.data.nextPlayer;
    }

    function hasValidGameCreateData() {
      let d = request.resource.data;
      return d.player1Id == request.auth.uid
        && d.player2Id == null
        && d.status == 'waiting'
        && d.nextPlayer == d.player1Id
        && d.winner == null;
    }
    
    function hasValidGameUpdateData(game) {
        let before = game.data;
        let after = request.resource.data;

        // --- Immutable Fields: These must never change.
        let areCoreFieldsImmutable = before.player1Id == after.player1Id && before.createdAt == after.createdAt;
        if (!areCoreFieldsImmutable) {
            return false;
        }

        // --- Scenario 1: A second player is joining a waiting game.
        let isJoining = before.status == 'waiting' && after.status == 'active';
        if (isJoining) {
            return after.player2Id == request.auth.uid &&                  // The joining player must be the one making the request.
                   request.auth.uid != before.player1Id &&                 // A player cannot join their own game.
                   before.player2Id == null &&                             // The second player slot must be empty.
                   // Verify that no other fields were maliciously changed during the join operation.
                   after.board == before.board &&
                   after.nextPlayer == before.nextPlayer &&
                   after.winner == before.winner;
        }
        
        // --- Scenario 2: An active player is making a move.
        let isMakingMove = isNextPlayer(game) &&
                           before.status == 'active' &&
                           after.status != 'waiting' && // Status can change to 'active' or 'finished'.
                           before.board != after.board &&
                           before.player2Id == after.player2Id; // player2 cannot be changed mid-game.
        if(isMakingMove) {
          return true; // The move itself (board, nextPlayer, status, winner) is complex, so we allow it if the basic conditions are met.
        }

        // --- Scenario 3: A player is forfeiting the game.
        let isForfeiting = isGamePlayer(game) &&
                           before.status == 'active' &&
                           after.status == 'finished' &&
                           after.winner != request.auth.uid && // The winner cannot be the one who forfeited.
                           after.winner != 'draw' &&
                           after.winner != null; // There must be a winner.
        if (isForfeiting) {
          return true;
        }

        // If none of the valid update scenarios match, deny the request.
        return false;
    }


    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserCreateData(userId);
      allow update: if isExistingOwner(userId) && hasValidUserUpdateData();
      allow delete: if isExistingOwner(userId);

      match /settings/{settingId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidSettingCreateData(userId);
        allow update: if isExistingOwner(userId) && hasValidSettingUpdateData();
        allow delete: if isExistingOwner(userId);
      }

      match /game_records/{gameRecordId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidGameRecordCreateData(userId);
        allow update: if isExistingOwner(userId) && hasValidGameRecordUpdateData();
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Manages live multiplayer game sessions.
     * @path /games/{gameId}
     * @allow (read, list) Any authenticated user can read or list games to find an open match.
     * @allow (create) An authenticated user can create a new game, becoming player1.
     * @allow (update) Players can join a waiting game or make a move if it's their turn.
     * @deny (delete) Games cannot be deleted to preserve history temporarily.
     */
    match /games/{gameId} {
        allow get, list: if isSignedIn();
        allow create: if isSignedIn() && hasValidGameCreateData();
        allow update: if isSignedIn() && hasValidGameUpdateData(resource);
        allow delete: if false;
    }
  }
}
